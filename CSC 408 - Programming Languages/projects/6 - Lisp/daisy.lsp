(defun shuffle (list &optional (destructive nil)
                     &aux (new-list (if destructive list (copy-list list)))
               (n (length new-list)))
  (loop for i below n do (rotatef (elt new-list i)
                                  (elt new-list  (random n))))
  new-list)

(defun my_life(x y l c)
     (with-open-file (outfile "daisy.out" :direction :output :if-exists :append)
           (prin1 x outfile)(princ #\Space outfile)(prin1 y outfile)(princ #\Newline outfile)
     )	    
     (setq univ nil)
     (setq univ2 nil)
     ;;;populate univ with daisies
     (dotimes (count x)
          (setq univ(cons 'd univ)))
     (setq empty (- l x))
     (setq empty (- empty y))
     ;;;populate univ with blanks
     (dotimes (count empty)
           (setq univ(cons 'x univ)))
     ;;;populates univ with armos
     (dotimes (count y)
           (setq univ(cons '0 univ)))
     ;;;loop through number cycles	   
     (dotimes (count c)	   
     ;;;randomizes list
     (setq univ(shuffle univ))
     ;;;go through list decrementing numbers and storing new values in univ2
     (dotimes (count l univ2)
           (setq a (car univ))
	   (setq univ(rest univ))
	   (if (numberp a) (setq a(- a 1)))
	   (setq univ2(cons a univ2)))
     ;;;grab two elements and check to see if changes are made in list
       (dotimes (count l univ) 
           (setf a (first univ2))
	   (setf b (second univ2))
	   (if (eql a '-3) (setf a 'X))
	   (if (and (eql a '3) (eql b '3))
	          (setf (third univ) '-1))
	   (cond ((equal a 'D) 
	            (cond ((numberp b) 
	                   (and (setf a 'X) (setf (second univ2)(+ b 1)))
			  )
			  ((eql b 'X) (setf (second univ2) 'D)
			  )
		    )
                 )
		 ((equal a 'X)
		    (cond ((equal b 'D)
		            (setf a 'D)
			  )
		     )
		 )
		 ((numberp a)
		    (cond ((equal b 'D)
		           (and (setf a (+ a 1)) (setf (second univ2) 'X))
			  )
		     )
		 )    
           )
	   (setf univ(cons a univ))
	   (setq univ2 (rest univ2))
 	 )  
	   (setq test univ)
	   (setf daisy '0)
           (setf arm '0)
         (dotimes (count l)
           (setf a (car test))
	   (setq test (rest test))
           (cond ((eql a 'D) (setf daisy (+ daisy 1))
                 )
	         ((numberp a)(setf arm (+ arm 1))
	         )
            )
	  ) 
           (with-open-file (outfile "daisy.out" :direction :output :if-exists :append)
               (prin1 daisy outfile)(princ #\Space outfile)(prin1 arm outfile)(princ #\Newline outfile)
            )  
	    
	 )
)	   

